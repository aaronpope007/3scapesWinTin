#CLASS {mip} {kill}
#CLASS {mip} {open}

#NOP ***** Set MIP ID Code **********
#VAR {mip} {}
#LOOP {1} {5} {i} {
	#MATH {temp[digit]} {1d10 - 1};
	#VAR {mip[id]} {$mip[id]$temp[digit]}
}
#UNVAR {temp[digit]}
#info system save

#NOP ***** Kick Off MIP *************
#DELAY {3klient} {
	#SEND 3klient $mip[id]~~$info[SYSTEM][CLIENT_NAME]$info[SYSTEM][CLIENT_VERSION];
	#SEND 3klient LINEFEED on;
	#SEND 3klient HAA off;
	#SEND forcehp;
}{2};

#NOP ***** Deadman Protection - Blocks all sends when idle > 15 min *****
#ALIAS {safe_send} {
	#if {$deadman_active == 1} {
		#echo {<128>[DEADMAN] BLOCKED: %0 - Idle exceeds 15 min limit<088>};
	} {
		#send {%0};
	}
}

#NOP ***** Extract Raw Data *********
#ACTION {{%*\#K\%$mip[id](.{3})(.{3})(.*)}$} {
	#VAR {mip[source]} {%0};
	#VAR {mip[%3][data]} {%4};
	.mipProcessFlag {%3} {%4};

	#IF {"$mip[echo]" != "on"} {
		#LINE GAG
	}
} {1}

#ALIAS {update_caption} {
	#format {world_cap}	{%-8s}	{$world};
	#format {world_cap}	{%n}	{$world_cap};
	#format {uptime_cap}	{%+8s}	{$session[uptime]};
	#format {reboot_cap}	{%+5s}	{$session[reboot]};
	#format {lag_cap}	{%+4s}	{$session[lag]};
	#math	{idle_hr}	{$idle / 3600};
	#math	{idle_min}	{$idle % 3600 / 60};
	#math	{idle_sec}	{$idle % 60};
	#if	{$idle_hr < 10}	{#var idle_hr  0$idle_hr};
	#if	{$idle_min < 10}{#var idle_min 0$idle_min};
	#if	{$idle_sec < 10}{#var idle_sec 0$idle_sec};
	#format {idle_cap}	{%+4s}	{<268>[<128>$idle_hr<268>:<128>$idle_min<268>:<128>$idle_sec<268>]<088>};

		#if {"$mapping" == "on"} {
		#format {mapstatus} {<068>[MAPPING]<088>};
	} {
		#var mapstatus {};
	};

	#switch {$stepignore} {
		#case {0} {
			#if {$bot} {
				#if {$autokill} {
					#format {stepper} {<068>[S:B(A)]};
				} {
					#format {stepper} {<068>[S:B(P)]};
				};
			} {
				#format {stepper} {<068>[S]<088>};
			};		
		};
		#case {1} {
			#if {$bot} {
				#if {$autokill} {
					#format {stepper} {<068>[M:B(A)]};
				} {
					#format {stepper} {<068>[M:B(P)]};
				};
			} {
				#var stepper {<068>[M]};
			};
		};
		#case {2} {
			#var stepper {<068>[W]};
		};
		#case {3} {
			#var stepper {<068>[C]};
		};
	};

	#if	{&botcycle[] > 0} {
		#format {areacap} {<148>Cycle: <168>$cycle<148>\-<168>$botcycle[$cycle]<088>}
	} {
		#var areacap {};	
	};
	#if {$bot == 1} {
		#if {$autokill} {
			#format {botstatus} {<068>[BOT:ON]<088>};
		} {
			#format {botstatus} {<128>[BOT:PAUSED]<088>};
		}
	} {
		#format {botstatus} {<128>[BOT:OFF]<088>};
	};
	#if {$idle > $IdleLimit} {
		#if {$bot_was_active == 1} {
			#format {idlewarning} {<128>[IDLED OUT]<088>};
		} {
			#format {idlewarning} {<128>[IDLE WARNING]<088>};
		}
	} {
		#var idlewarning {};
	};
	#if {"$bot_stop_reason" != ""} {
		#format {stopreason} {<128>[$bot_stop_reason]<088>};
	} {
		#var stopreason {};
	};
	#if {"$draw[caption]" == "on"} {
		#SHOWME {<088> <128>$world_cap <068>Uptime: <168>$uptime_cap  <038>Reboot: <138>$reboot_cap  <fca>Lag: <fcb>$lag_cap  <228>Idle: $idle_cap<088>  $areacap<088> $stepper $mapstatus $botstatus $idlewarning $stopreason} {19}
		#if {$idle > $IdleLimit} {
			#if {$bot_was_active == 1} {
				#SHOWME {<128>****************************************<088>} {20}
				#SHOWME {<128>*  BOT DEACTIVATED DUE TO IDLE TIME  *<088>} {21}
				#SHOWME {<128>*  Will auto-restart on next input  *<088>} {22}
			} {
				#SHOWME {<128>****************************************<088>} {20}
				#SHOWME {<128>*  WARNING: IDLE TIME EXCEEDED 15 MIN  *<088>} {21}
				#SHOWME {<128>****************************************<088>} {22}
			}
		} {
			#SHOWME {<088>} {20}
			#SHOWME {<088>} {21}
			#SHOWME {<088>} {22}
		}
	};
}

#var clockon 0
#var IdleLimit 900
#var idle_warned 0
#var bot_was_active 0
#var deadman_flash 0
#var deadman_active 0
#var last_input_ticks -1000
#var tick_counter 0
#var bot_stop_reason {}
#TICKER {idle} {
	#math {idle} {$idle + 1};
	#math {tick_counter} {$tick_counter + 1};
	#if {$idle > 900} {
		#draw tile 21 1 -8 1 {<BF00>}
	}; #elseif {$idle > 840} {
		#draw tile 21 1 -8 1 {<BFF0>}
	}; #elseif {$idle > 600} {
		#draw tile 21 1 -8 1 {<B0F0>}
	}; #elseif {$idle < 600} {
		#screen clear square 21 1 -8 1
	};
	#if {$idle > $IdleLimit} {
		#if {$idle_warned == 0} {
			#bell;
			#var idle_warned 1;
			#echo {};
			#echo {<128>****************************************<088>};
			#echo {<128>*  WARNING: IDLE TIME EXCEEDED 15 MIN  *<088>};
			#echo {<128>*  You have been idle for 15+ minutes  *<088>};
			#echo {<128>****************************************<088>};
			#echo {};
		};
		#var deadman_active 1;
		#NOP Force stop all keepalives when idle limit exceeded
		#if {$keepalive_active == 1} {
			#unticker party_keepalive;
			#var keepalive_active 0;
			#echo {<128>[Keepalive] FORCE STOPPED - Idle limit exceeded<088>};
		}
	} {
		#var deadman_active 0;
	};
	#if {$bot == 1 && $idle > $IdleLimit && $idle_warned == 1} {
		#math {ticks_since_input} {$tick_counter - $last_input_ticks};
		#if {$ticks_since_input > 60 || $last_input_ticks < 0} {
			#bell;
			#echo {};
			#echo {<128>****************************************<088>};
			#echo {<128>*  BOT DEACTIVATED DUE TO IDLE TIME  *<088>};
			#echo {<128>*  Idle limit exceeded: 15 minutes   *<088>};
			#echo {<128>*  Idle: $idle seconds               *<088>};
			#echo {<128>*  Ticks since input: $ticks_since_input *<088>};
			#echo {<128>*  Bot stopped                       *<088>};
			#echo {<128>*  Will auto-restart on next input  *<088>};
			#echo {<128>****************************************<088>};
			#echo {};
			#var bot_was_active 1;
			#var bot_stop_reason {DEADMAN: Idle $idle};
			#echo {<128>[Deadman] Trigger fired - Idle: $idle, Limit: $IdleLimit, Ticks since input: $ticks_since_input, Last input ticks: $last_input_ticks, Current tick: $tick_counter<088>};
			.stop;
			#unvar bot;
		} {
			#echo {<068>[Deadman] Prevented - Input too recent (Ticks: $ticks_since_input, Last: $last_input_ticks, Current: $tick_counter)<088>};
		}
	};
	#if {$bot == 1 && "$bot_stop_reason" != ""} {
		#var bot_stop_reason {};
	};
	#if {$bot != 1 && "$bot_stop_reason" != "" && $idle < 60} {
		#var bot_stop_reason {};
		#var bot_was_active 0;
	};
	update_caption
} {1}

#TICKER {deadman_warning} {
	#if {$idle > $IdleLimit && $idle_warned == 1} {
		#if {$deadman_flash == 0} {
			#var deadman_flash 1;
			#if {$bot == 1} {
				#echo {<fca><fff>*** [DEADMAN WARNING] Bot active but idle for $idle seconds (15 min limit exceeded) - Bot will stop soon! ***<088>};
				#echo {<fca><fff>*** [DEADMAN WARNING] Bot active but idle for $idle seconds (15 min limit exceeded) - Bot will stop soon! ***<088>};
				#echo {<fca><fff>*** [DEADMAN WARNING] Bot active but idle for $idle seconds (15 min limit exceeded) - Bot will stop soon! ***<088>};
			} {
				#if {$keepalive_active == 1} {
					#echo {<fca><fff>*** [DEADMAN WARNING] Keepalive active but idle for $idle seconds (15 min limit exceeded) ***<088>};
					#echo {<fca><fff>*** [DEADMAN WARNING] Keepalive active but idle for $idle seconds (15 min limit exceeded) ***<088>};
					#echo {<fca><fff>*** [DEADMAN WARNING] Keepalive active but idle for $idle seconds (15 min limit exceeded) ***<088>};
				} {
					#echo {<fca><fff>*** [DEADMAN WARNING] Idle for $idle seconds (15 min limit exceeded) - No bot or keepalive active ***<088>};
					#echo {<fca><fff>*** [DEADMAN WARNING] Idle for $idle seconds (15 min limit exceeded) - No bot or keepalive active ***<088>};
					#echo {<fca><fff>*** [DEADMAN WARNING] Idle for $idle seconds (15 min limit exceeded) - No bot or keepalive active ***<088>};
				}
			}
		} {
			#var deadman_flash 0;
			#if {$bot == 1} {
				#echo {<fcb><fff>*** [DEADMAN WARNING] Bot active but idle for $idle seconds (15 min limit exceeded) - Bot will stop soon! ***<088>};
				#echo {<fcb><fff>*** [DEADMAN WARNING] Bot active but idle for $idle seconds (15 min limit exceeded) - Bot will stop soon! ***<088>};
				#echo {<fcb><fff>*** [DEADMAN WARNING] Bot active but idle for $idle seconds (15 min limit exceeded) - Bot will stop soon! ***<088>};
			} {
				#if {$keepalive_active == 1} {
					#echo {<fcb><fff>*** [DEADMAN WARNING] Keepalive active but idle for $idle seconds (15 min limit exceeded) ***<088>};
					#echo {<fcb><fff>*** [DEADMAN WARNING] Keepalive active but idle for $idle seconds (15 min limit exceeded) ***<088>};
					#echo {<fcb><fff>*** [DEADMAN WARNING] Keepalive active but idle for $idle seconds (15 min limit exceeded) ***<088>};
				} {
					#echo {<fcb><fff>*** [DEADMAN WARNING] Idle for $idle seconds (15 min limit exceeded) - No bot or keepalive active ***<088>};
					#echo {<fcb><fff>*** [DEADMAN WARNING] Idle for $idle seconds (15 min limit exceeded) - No bot or keepalive active ***<088>};
					#echo {<fcb><fff>*** [DEADMAN WARNING] Idle for $idle seconds (15 min limit exceeded) - No bot or keepalive active ***<088>};
				}
			}
		}
	} {
		#var deadman_flash 0;
	}
} {2}

#EVENT {RECEIVED INPUT} {
	#var old_idle $idle;
	#var idle 0;
	#var idle_warned 0;
	#var deadman_active 0;
	#var last_input_ticks $tick_counter;
	#if {$bot == 1} {
		#echo {<068>[Idle] Reset from $old_idle to 0 (Bot active, Ticks: $tick_counter)<088>};
	};
	#if {$keepalive_active == 1} {
		#unticker party_keepalive;
		#ticker {party_keepalive} {
			#if {$idle >= $IdleLimit} {
				#unticker party_keepalive;
				#var keepalive_active 0;
				#echo {<128>[Party Keepalive] STOPPED - Idle $idle exceeds limit $IdleLimit - NO COMMANDS SENT<088>};
				update_caption;
			} {
				#if {$keepalive_active == 1 && $idle < $IdleLimit} {
					#echo {<068>[Party Keepalive] Sending keepalive (Idle: $idle / $IdleLimit)<088>};
					#echo {<128>*** SENDING CARRIAGE RETURN ***<088>};
					#send {};
					update_caption;
				} {
					#if {$keepalive_active == 0} {
						#unticker party_keepalive;
					}
				}
			}
		} {299};
		#echo {<068>[Keepalive] Timer reset by user input (299s countdown restarted)<088>};
		update_caption;
	};
	#if {$keepalive_active == 0} {
		#var keepalive_active 1;
		#var keepalive_was_active 1;
		#ticker {party_keepalive} {
			#if {$idle >= $IdleLimit} {
				#unticker party_keepalive;
				#var keepalive_active 0;
				#echo {<128>[Party Keepalive] STOPPED - Idle $idle exceeds limit $IdleLimit - NO COMMANDS SENT<088>};
				update_caption;
			} {
				#if {$keepalive_active == 1 && $idle < $IdleLimit} {
					#echo {<068>[Party Keepalive] Sending keepalive (Idle: $idle / $IdleLimit)<088>};
					#echo {<128>*** SENDING CARRIAGE RETURN ***<088>};
					#send {};
					update_caption;
				} {
					#if {$keepalive_active == 0} {
						#unticker party_keepalive;
					}
				}
			}
		} {299};
		#echo {<068>[Keepalive] Auto-restarted after user input<088>};
		update_caption;
	};
	#if {$bot != 1 && $bot_was_active == 1} {
		#var bot 1;
		#var autokill 1;
		#var idle_warned 0;
		#var bot_stop_reason {};
		#echo {<068>[Bot] Auto-restarted after user input<088>};
		update_caption;
		#NOP Always resume movement when bot restarts
		#delay {0.5} {ki}
	}
}

#TICKER {keepalive} {
	#if {$idle >= $IdleLimit} {
		#echo {<128>[Keepalive] STOPPED - Idle $idle exceeds limit $IdleLimit - NO COMMANDS SENT<088>};
	} {
		#if {$bot == 1 && $idle < $IdleLimit} {
			#echo {<068>[Keepalive] Sending keepalive signal (Idle: $idle / $IdleLimit)<088>};
			#echo {<128>*** SENDING CARRIAGE RETURN ***<088>};
			#send {}
		}
	}
} {299}

#NOP Standalone keepalive for party mode (works without bot) - Auto-starts by default
#var keepalive_active 1
#var keepalive_count 0
#var keepalive_was_active 1
#ticker {party_keepalive} {
	#if {$idle >= $IdleLimit} {
		#unticker party_keepalive;
		#var keepalive_active 0;
		#echo {<128>[Party Keepalive] STOPPED - Idle $idle exceeds limit $IdleLimit - NO COMMANDS SENT<088>};
		update_caption;
	} {
		#if {$keepalive_active == 1 && $idle < $IdleLimit} {
			#echo {<068>[Party Keepalive] Sending keepalive (Idle: $idle / $IdleLimit)<088>};
			#echo {<128>*** SENDING CARRIAGE RETURN ***<088>};
			#send {};
			update_caption;
		} {
			#if {$keepalive_active == 0} {
				#unticker party_keepalive;
			}
		}
	}
} {299}

#alias {.keepalive} {
	#if {$keepalive_active == 1} {
		#unticker party_keepalive;
		#var keepalive_active 0;
		#var keepalive_count 0;
		#var keepalive_was_active 0;
		#echo {<128>Party keepalive stopped (will auto-restart on next input)<088>};
		update_caption;
	} {
		#var keepalive_active 1;
		#var keepalive_was_active 1;
		#ticker {party_keepalive} {
			#if {$idle >= $IdleLimit} {
				#unticker party_keepalive;
				#var keepalive_active 0;
				#echo {<128>[Party Keepalive] STOPPED - Idle $idle exceeds limit $IdleLimit - NO COMMANDS SENT<088>};
				update_caption;
			} {
				#if {$keepalive_active == 1 && $idle < $IdleLimit} {
					#echo {<068>[Party Keepalive] Sending keepalive (Idle: $idle / $IdleLimit)<088>};
					#echo {<128>*** SENDING CARRIAGE RETURN ***<088>};
					#send {};
					update_caption;
				} {
					#if {$keepalive_active == 0} {
						#unticker party_keepalive;
					}
				}
			}
		} {299};
		#echo {<068>Party keepalive started (sends every 299s, stops at 15min idle)<088>};
		update_caption;
	}
}

#NOP ***** Individual Data Sections *****
#ALIAS {.mipProcessFlag} {
	#SWITCH {"%1"} {
		#CASE {"AAA"} {#NOP Sound};
		#CASE {"AAB"} {#NOP Image};
		#CASE {"AAC"} {#NOP Reboot Time;#VAR {session[reboot]} {%2};update_caption};
		#CASE {"AAD"} {#NOP Music};
		#CASE {"AAF"} {#NOP Uptime;#VAR {session[uptime]} {%2};update_caption};
		#CASE {"AAG"} {#NOP AVI movie};
		#CASE {"AAH"} {#NOP Download Media};
		#CASE {"BAA"} {#NOP Special Textstring;#showme {%2} {2}};
		#CASE {"BAB"} {#NOP 2 Way Communications;.mipProcessBABgag {%2}};
		#CASE {"BAC"} {#NOP Special Textstring2};
		#CASE {"BAD"} {#NOP Room Description};
		#CASE {"BAE"} {#NOP Mud Lag;#VAR {session[lag]} {%2};update_caption};
		#CASE {"BAF"} {#NOP Send Edit};
		#CASE {"BBA"} {#NOP Guild Point1 Mask;#FORMAT {my[gp1][name]} {%s} {%2}};
		#CASE {"BBB"} {#NOP Guild Point2 Mask;#FORMAT {my[gp2][name]} {%s} {%2}};
		#CASE {"BBC"} {#NOP Hit Point Mask;#FORMAT {my[hp][name]} {%s} {%2}};
		#CASE {"BBD"} {#NOP Spell Point Mask;#FORMAT {my[sp][name]} {%s} {%2}};
		#CASE {"CAA"} {#NOP Chat Messages;.mipProcessCAAgag {%2}};
		#CASE {"CAP"} {#NOP Window Caption Text;#FORMAT {temp} {%h} {%2};#showme {$temp} {2}};
		#CASE {"CCF"} {#NOP Send File Line};
		#CASE {"CDF"} {#NOP Send File Begin};
		#CASE {"CEF"} {#NOP Send File End};
		#CASE {"DDD"} {#NOP Room Exits;#NOP Split at Hex 160 (Non Breaking Space)};
		#CASE {"FFF"} {#NOP Combined Stats Data;.mipProcessFFF {%2}};
		#CASE {"HAA"} {#NOP Room Items};
		#CASE {"HAB"} {#NOP Item Actions;.mipProcessHAB {%2}};
		#DEFAULT {#NOP Every other non-handled flag;#showme <148>UNHANDLED MIP: %0<088>}
	}
}

#NOP ***** Combined Stats Data *****
#ALIAS {.mipProcessFFF} {
	#VAR {mip[FFF][flag]} {0};
	#VAR {mip[FFF][toggle]} {0};
	#PARSE {%1} {i} {
		#IF {"$mip[FFF][flag]" == "0"} {
			#VAR {mip[FFF][flag]} {$i};
			#VAR {mip[FFF][$i]} {};
			#VAR {mip[FFF][$i][data]} {};
		} {
			#IF {"$i" == "~"} {
				#IF {"$mip[FFF][toggle]" == "0"} {
					#VAR {mip[FFF][toggle]} {1}
				} {
					.mipProcessFFFSub {$mip[FFF][flag]} {$mip[FFF][${mip[FFF][flag]}][data]};
					#VAR {mip[FFF][flag]} {0};
					#VAR {mip[FFF][toggle]} {0}
				}
			} {
				#VAR {mip[FFF][${mip[FFF][flag]}][data]} {${mip[FFF][${mip[FFF][flag]}][data]}${i}}
			}
		}
	};
	#IF {"$mip[FFF][$mip[FFF][flag]][data]" != ""} {
		.mipProcessFFFSub {$mip[FFF][flag]} {$mip[FFF][${mip[FFF][flag]}][data]}
	}
}

#NOP ***** Separated Stats Data *****
#ALIAS {.mipProcessFFFSub} {
	#SWITCH {"%1"} {
		#CASE {"A"} {#NOP Hit Points;#VAR {my[hp][current]} {%2}};
		#CASE {"B"} {#NOP Hit Points Maximum;#VAR {my[hp][max]} {%2}};
		#CASE {"C"} {#NOP Spell Points;#VAR {my[sp][current]} {%2}};
		#CASE {"D"} {#NOP Spell Points Maximum;#VAR {my[sp][max]} {%2}};
		#CASE {"E"} {#NOP Guild Points1;#VAR {my[gp1][current]} {%2}};
		#CASE {"F"} {#NOP Guild Points1 Maximum;#VAR {my[gp1][max]} {%2}};
		#CASE {"G"} {#NOP Guild Points2;#VAR {my[gp2][current]} {%2}};
		#CASE {"H"} {#NOP Guild Points2 Maximum;#VAR {my[gp2][max]} {%2}};
		#CASE {"I"} {#NOP Primary Guild Line;.mipProcessGline {1} {%2}};
		#CASE {"J"} {#NOP Secondary Guild Line;.mipProcessGline {2} {%2}};
		#CASE {"K"} {#NOP Mob Fighting;.mipProcessFFFK {%2}};
		#CASE {"L"} {#NOP Mob Health;#VAR {enemy[hp]} {%2}};
		#CASE {"M"} {#NOP Mob Image File};
		#CASE {"N"} {#NOP Combat Round Counter;#VAR {mip[round]} {%2}};
		#DEFAULT {#NOP Every other non-handled flag}
	};
	#NOP update_status alias defined in personal hpbar trigger;
	update_status
}

#NOP ***** Combat Mob Name *****;
#ALIAS {.mipProcessFFFK} {
	#IF {"%1" != ""} {
		#VAR {enemy} {};
		#VAR {enemy[name]} {%1}
	} {
		#VAR {enemy[hp]} {}
	}
}

#NOP ***** Guild Stats Line 1/2 *****
#ALIAS {.mipProcessGline} {
	#VAR {mip[gline][%1]} {@fMipColorConv{%2}};
	#VAR {temp} {};

	#NOP GUILD SPECIFIC GLINE PROCESSING;
	#IF {"%2" != ""} {
		#SWITCH {"$guild"} {
			#CASE {"changeling"}	{.mipProcessGlineChangeling {%1}};
			#CASE {"elemental"}	{.mipProcessGlineElemental {%1}};
			#CASE {"jedi"}		{.mipProcessGlineJedi {%1}};
			#CASE {"juggernaut"}	{.mipProcessGlineJuggernaut {%1}};
			#CASE {"necromancer"}	{.mipProcessGlineNecromancer {%1}};
			#CASE {"psicorp"}	{.mipProcessGlinePsicorp {%1}};
			#CASE {"sii"}		{.mipProcessGlineSii {%1}}
			#CASE {"angel"}		{.mipProcessGlineAngel {%1}}
			#CASE {"mages"}		{.mipProcessGlineMages {%1}}
		}
	}
}

#ALIAS {.mipProcessGlineMages} {
	#IF {%1 == 1} {#NOP
	}; #ELSEIF {%1 == 2} {
		#replace {mip[gline][2]}{Bridge}{Bri};
		#replace {mip[gline][2]}{Inevitability}{Ine};
		#replace {mip[gline][2]}{Stability}{Sta};
		#replace {mip[gline][2]}{conglomeration}{Con};
		#replace {mip[gline][2]}{elemental}{Ele};
		#replace {mip[gline][2]}{maelstrom}{Mae};
		#replace {mip[gline][2]}{Flame}{Fl};
		#replace {mip[gline][2]}{Moonlight}{Mo};
		#replace {mip[gline][2]}{Lightning}{Li};
		#replace {mip[gline][2]}{Mist}{Mi};
		#replace {mip[gline][2]}{V:%d, }{V,};
	}; #ELSE {
		#ECHO {<171 Invalid Gline Number <088>}
	}
}

#ALIAS {.mipProcessGlineAngel} {
	#IF {%1 == 1} {
		#REGEX {$mip[gline][1]}	{Station: %d.%d\%} {
			#VAR {my[station][current]}		{&1.&2};
		};
	}; #ELSEIF {%1 == 2} {
		#REGEX {$mip[gline][2]}	{Pos: %* Con:} {
			#VAR {my[possess][body]}		{&1};
		}{
			#REGEX {$mip[gline][2]}	{Pos: %*} {
				#VAR {my[possess][body]}		{&1};
				#replace {my[possess][body]}{  }{};
			}{
				#var {my[possess][body]}{None};
			};
		};
	}; #ELSE {
		#ECHO {<171> Invalid Gline Number <088>}
	}
}

#ALIAS {.mipProcessGlineChangeling} {
	#IF {%1 == 1} {
		#REGEX {$mip[gline][1]} {Chaos Flux: %d/%d} {
			#VAR {my[relinquish][current]}	{&1};
			#VAR {my[relinquish][reset]}	{&2}
		};
		#REGEX {$mip[gline][1]} {{Density|Homeostasis|Mitosis|Morphogenesis|Resilience}: %d.%d\%} {
			#VAR {my[skill][name]}		{&1};
			#VAR {my[skill][current]}	{&2.&3}
		};
		#REGEX {$mip[gline][1]}	{\[{FF|IL}\(%d\): %d.%d\%\]>  \[%D\]} {
			#VAR {my[ff][current]}		{&3.&4};
			#VAR {my[form]}			{&5}
		}
		#REGEX {$mip[gline][1]}	{FF(%d)} {
			#VAR {my[ff][level]}		{&1};
		};
		#REGEX {$mip[gline][1]}	{IL(%d)} {
			#VAR {my[ff][level]}		{&1+};
		};
		#REGEX {$mip[gline][1]}	{FF(MAX)} {
			#VAR {my[ff][level]}		{MAX};
		};
		#REGEX {$mip[gline][1]}	{IL(_MAX_)} {
			#VAR {my[ff][level]}		{_MAX_};
		};
	}; #ELSEIF {%1 == 2} {
		#REGEX {$mip[gline][2]}	{\[Bioplasts: %d\]} {#VAR {my[bioplasts]}	{&1}}
	}; #ELSE {
		#ECHO {<171> Invalid Gline Number <088>}
	}
}

#ALIAS {.mipProcessGlineElemental} {
	#IF {%1 == 1} {
		#REGEX {Emit<099> : <%d>%d<099>}	{#VAR {my[emit][level]}		{&2}};
		#REGEX {Equipollent}			{#VAR {my[equip]}		{on}}
							{#VAR {my[equip]}		{off}};
		#REGEX {Form<099>: <869>%w<099>\(<819>%d<099>\)}		{
			#VAR {my[form][type]}		{&1};
			#VAR {my[form][size]}		{&2}
		};
		#REGEX {Rating<099>: <819>%d<099>}			{#VAR {my[rating]}		{&1}}
	}; #ELSEIF {%1 == 2} {
		#REGEX {Stones/Waves/Shrouds<099>: <%d>%d<099>/<%d>%d<099>/<%d>%d<099>\(%d\%\)}
			#VAR {my[blasts]		{&2};
			#VAR {my[waves]}		{&4};
			#VAR {my[shrouds]}		{&6};
			#VAR {my[reset]}		{&7}
		};
		#REGEX {G2N: <%d>%d<099>}		{#VAR {my[g2n]}			{&2}}
	}; #ELSE {
		#ECHO {<171> Invalid Gline Number <088>}
	}
}

#ALIAS {.mipProcessGlineJedi} {
	#IF {%1 == 1} {
		#REGEX {GXP:%s{[\d\.]+}\%}		{#VAR {my[gxp][current]}	{&2}};
	}; #ELSEIF {%1 == 2} {#NOP
	}; #ELSE {
		#ECHO {<171 Invalid Gline Number <088>}
	}
}
#ALIAS {.mipProcessGlineJuggernaut} {
	#IF {%1 == 1} {
		#REGEX {$mip[gline][1]} {Ammo:\[%d/%d/%d/%d/%d\] <838>Gxp: %d.%d\%<099> Hits: \[%d\] <868>Coffin: %d/%d} {
			#VAR {ammo[1]}			{&1};
			#VAR {ammo[2]}			{&2};
			#VAR {ammo[3]}			{&3};
			#VAR {ammo[4]}			{&4};
			#VAR {ammo[5]}			{&5};
			#VAR {gxp}			{&6.&7};
			#VAR {hits}			{&8};
			#VAR {corpses[coffin]}		{&9};
			#VAR {corpses[coffinsize]}	{&10}
		}
	}; #ELSEIF {%1 == 2} {
		#REGEX {$mip[gline][2]} {Nukes: [%d/%d]<099> Reset: [%d\%]} {
			#VAR {nukes}		{&1};
			#VAR {nukes_max}	{&2};
			#VAR {reset}		{&3}
		}
	}; #ELSE {
		#ECHO {<171> Invalid Gline Number <088>}
	}
}

#ALIAS {.mipProcessGlineNecromancer} {
	#IF {%1 == 1} {
		#REGEX {$mip[gline][1]} {C:%d}		{#VAR {corpses[inventory]}	{&1}};
		#REGEX {$mip[gline][1]} {Worth:%d}	{#VAR {my[worth]}		{&1}};
		#REGEX {$mip[gline][1]} {Tport:%d/%d}	{
			#VAR {my[ports][current]}	{&1};
			#VAR {my[ports][max]}		{&2}
		};
		#REGEX {$mip[gline][1]} {Sprk:%d/%d}	{
			#VAR {my[sparks][current]}	{&1};
			#VAR {my[sparks][max]}		{&2}
		};
		#REGEX {$mip[gline][1]} {Prot:%wX}	{#VAR {my[prot]}		{&1}};
		#REGEX {$mip[gline][1]} {Circle:%d}	{#VAR {my[gxp]}			{&1}}
	}; #ELSEIF {%1 == 2} {
		#REGEX {$mip[gline][2]}	{Undead:%w}	{#VAR {my[undead]}		{&1}};
		#REGEX {$mip[gline][2]}	{SPf:%d/%d}	{
			#VAR {my[sp][fuse][current]}	{&1};
			#VAR {my[sp][fuse][max]}	{&2}
		}
	}; #ELSE {
		#ECHO {<171> Invalid Gline Number <088>}
	}
}

#ALIAS {.mipProcessGlinePsicorp} {
	#IF {%1 == 1} {
		#NOP
	}; #ELSEIF {%1 == 2} {
		#REGEX {$mip[gline][2]} {G2N: %* / %d\%} {
			#FORMAT {my[gxp][tnl]} {%d} {&1};
			#VAR {my[gxp][per]} {&2}
		}
	}; #ELSE {
		#ECHO {<171> Invalid Gline Number <088>}
	}
}

#ALIAS {.mipProcessGlineSii} {
	#IF {%1 == 1} {
		#REGEX {$mip[gline][1]}	{Regen: %w}	{#VAR {my[regen]}		{&1}}
	}; #ELSEIF {%1 == 2} {
		#REGEX {$mip[gline][2]}	{Con:%d/%d}	{
			#VAR {my[control][current]}	{&1};
			#VAR {my[control][max]}		{&2}
		}
	}; #ELSE {
		#ECHO {<171> Invalid Gline Number <088>}
	}
}

#ALIAS {.mipProcessGlineBard} {
	#IF {%1 == 1} {
		
	}; #ELSEIF {%1 == 2} {
		
	}; #ELSE {
		#ECHO {<171> Invalid Gline Number <088>}
	}
}


#NOP ***** 2 Way Communication (Tell/Emote) *****
#ALIAS {.mipProcessBABgag} {
	#var mipgag 0;

	#NOP Duplicate 'from' soul;
	#REGEX {%0} {~you~} {#var mipgag 1};


	#NOP Add cases for tells/emotes to gag from monitor, such as mob emotes;

	#NOP Byron crying OW;
	#REGEX {%01} {~Byron~cries 'OW!!'} {#var mipgag 1};

	#NOP Dundee;
	#REGEX {%0} {~A~shiver runs through you as you successfully fight off an infection.} {#var mipgag 1};
	#REGEX {%0} {~Your~head throbs briefly as you successfully fight off an infection.} {#var mipgag 1};
	#REGEX {%0} {~Your~temperature spikes as you successfully fight off an infection.} {#var mipgag 1};
	#REGEX {%0} {~Your~palms begin to sweat as you successfully fight off an infection.} {#var mipgag 1};
	#REGEX {%0} {~Your~neck aches slightly as you successfully fight off an infection.} {#var mipgag 1};

	#NOP Mages;
	#REGEX {%0} {~Torrential~energies stream momentarily through the nexus of stability into the material world.} {#var mipgag 1};
	#REGEX {%0} {~Blazing~with strange energies, the nexus of stability momentarily becomes a conduit for extradimensional forces.} {#var mipgag 1};

	#NOP Changelings;
	#REGEX {%0} {tiny translucent bombardier beetle} {#var mipgag 1};

	#NOP Hell Cows;
	#REGEX {%0} {~A~cow falls, but the herd continues on!} {#var mipgag 1};
	#REGEX {%0} {~The~lonesome cow topples to the ground, the herd finally slain.} {#var mipgag 1};

	#NOP Knights;
	#REGEX {%0} {~Bela~} {#var mipgag 1};

	#NOP Lost Soul;
	#REGEX {%0} {~~You try to clasp onto the diamond spectacle, but your hands fall right through!} {#var mipgag 1};
	#REGEX {%0} {~~Bursts of %w colored energy shoot off from the spectacle.} {#var mipgag 1};
	#REGEX {%0} {~~The diamond-spectacle spins and turns on an unseen axis.} {#var mipgag 1};

	#NOP Party Divvy;
	#REGEX {%0} {[PARTY] GOLD divvy called by } {#var mipgag 1};
	#REGEX {%0} {[PARTY] coins called by } {#var mipgag 1};
	#REGEX {%0} {[PARTY] All gold divvied, total: } {#var mipgag 1};

	#NOP Sii;
	#REGEX {%0} {~Your~malicious attacks fade} {#var mipgag 1};
	#REGEX {%0} {~The~corpse explodes as a small vicious lizard-like creature bursts forth!} {#var mipgag 1};

	#NOP Zelligar's Headband;
	#REGEX {%0} { stumbles in confusion as the headband hypnotizes } {#var mipgag 1};
	#REGEX {%0} { stumbles in confusion as the amulet hypnotizes } {#var mipgag 1};

	#REGEX {%0} {~Korenth~} {#bell};
	#REGEX {%0} {~Zanadu~} {#bell};
	#REGEX {%0} {~Simon~} {#bell};
	#REGEX {%0} {~Setinekht~} {#bell};
	#IF {$mipgag == 0} {.mipProcessBAB %0}
}

#var chat[rows] 17
#var chat[page] 1
#var chat[max] 100

#ALIAS {show_chat} {
	#if {"$draw[chat]" == "on"}{
		#math chat[start]	{$chat[rows] * $chat[page]};
		#math chat[end]		{$chat[rows] * $chat[page] - $chat[rows] + 1};
		#line sub {var} #draw {tile} 1 1 $chat[rows] -$map[width]-2 $chat[log][-$chat[start]..-$chat[end]]
	};
}

#ALIAS {update_chat} {
	#if {&chat[log][] > $chat[max]} {
		#list chat[log] del 1
	};
	#list chat[log] ins -1 {%0};

	#class {chat} {write} {${varpath}/${mud}chat.var};
	show_chat
}

#ALIAS {resume_chat}{
	#if {$my[config][db][chat] == 1}{
		db_query_chat 99;
		#loop {1}{99}{count}{
			#list chat[log] ins -1 {${db_chat_query[$count][timestamp]} ${db_chat_query[$count][message]}};
		};
		#unvar db_chat_query;
	}{
		#script {tail -n 99 ${logpath}/3s.chat | awk '{print "#list chat[log] ins -1 {"$0"}"}'};
	};
	show_chat;
};

#ALIAS {chatup} {
	#if {$chat[rows]*{$chat[page]+1} <= $chat[max] && $chat[rows]*{$chat[page]+1} <= &chat[log][]} {
		#math chat[page] {$chat[page]+1};
		show_chat;
	};
};
#ALIAS {chatdown} {
	#if {$chat[page] > 1} {
		#math chat[page] {$chat[page]-1};
		show_chat
	}
}
#ALIAS {chatend} {
	#math chat[page] 1;
	show_chat
}

#ALIAS {.mipProcessBAB} {
	#REGEX {%1} {{(.*)\~(.*)\~(.*)}} {
		#IF {"&3" != "0"} {
			#var mip[comm][data]	{&4};
			#var mip[comm][source]	{&3};
			#var mip[comm][line]	{Tell};
			#var mip[comm][command]	{tell $mip[comm][source]};
			#format {timestamp} {%t} {[<268>%H<088>:<268>%M<088>] };
			#format {dbtimestamp} {%t} {[%Y:%m:%d %H:%M:%S]};
			#IF {"&2" == "x"} {
				#NOP Message to another player;
				#var mip[comm][twoway] {to};
				#if {$my[config][db][chat] == 1}{
					#var {dbmess}{To &3: &4};
					db_submit_chat $dbmess;
				}{
					#line log {${logpath}/3s.chat} {$timestamp\};
					#line log {${logpath}/3s.chat} {<178>To &3<088>: &4};
				};
				update_chat ${timestamp}<178>To &3<088>: &4;
			} {
				#NOP Message from another player;
				#var mip[comm][twoway] {from};
				#if {$my[config][db][chat] == 1}{
					#var {dbmess}{&3: &4};
					db_submit_chat $dbmess;
				}{
					#line log {${logpath}/3s.chat} {$timestamp\};
					#line log {${logpath}/3s.chat} {<178>&3<088>: &4};
				};
				update_chat ${timestamp}<178>&3<088>: &4;

				#NOP Chat Tools;
				#if  {$idle <= 900} {
					#NOP 8Inix;
					#if {"$8inix" == "on"} {
						#regex {$mip[comm][data]} {%i8inix} {
							do8inix
						}
					};

					#NOP IDefine;
					#if {"$idefine" == "on"} {
						#regex {$mip[comm][data]} {%iidefine} {
							dodefine
						}
					};

					#NOP UDefine;
					#if {"$udefine" == "on"} {
						#regex {$mip[comm][data]} {%iudefine} {
							doudefine
						}
					};

					#NOP ADDS;
					#if {"$adds" == "on"} {
						#regex {$mip[comm][data]} {%iiwx} {
							doadds
						}
					};

					#NOP Stocks;
					#if {"$stocks" == "on"} {
						#regex {$mip[comm][data]} {%iistocks} {
							dostocks
						} {
							#regex {$mip[comm][data]} {%iistock} {
								dostock
							}
						}
					};

					#NOP Crypto;
					#if {"$crypto" == "on"} {
						#regex {$mip[comm][data]} {%i: icrypto} {
							docrypto
						}
					}
				}
			}
		}
	}
}

#NOP ***** Broadcast Communication (Chat/Shout) *****
#ALIAS {.mipProcessCAAgag} {
	#var mipgag 0;

	#NOP Party Divvy gagsd	#NOP Party Divvy;
        #REGEX {%0} {[PARTY] GOLD divvy called by } {#var mipgag 1};
	#REGEX {%0} {[PARTY] coins called by} {#var mipgag 1};
	#REGEX {%0} {[PARTY] Divvy of %d coins called by} {#var mipgag 1};
        #REGEX {%0} {[PARTY] All gold divvied, total: } {#var mipgag 1};

	#IF {$mipgag == 0} {.mipProcessCAA %0}
}
#ALIAS {.mipProcessCAA} {
	#REGEX {%1} {{(.*)\~(.*)\~(.*)\~(.*)}} {
		#var {mip[comm][command]}	{&2};
		#var {mip[comm][line]}		{&3};
		#var {mip[comm][source]}	{&4};
		#var {mip[comm][data]}		{&5};
		#format {timestamp} {%t} {[<268>%H<088>:<268>%M<088>] };
		#format {dbtimestamp} {%t} {[%Y:%m:%d %H:%M:%S]};

		#NOP Ansify lines;
		#var {commcol} {<178>};
		#switch {"$mip[comm][line]"} {
			#case {"ADMIN"}			{#var {commcol} {<158>}};
			#case {"Bear"}			{#var {commcol} {<168>}};
			#case {"Bloodname"}		{#var {commcol} {<138>}};
			#case {"Clan Cad"}		{#var {commcol} {<158>}};
			#case {"Com"}			{#var {commcol} {<128>}};
			#case {"Cyborg Com"}		{#var {commcol} {<138>}};
			#case {"Cyborg Death"}		{#var {commcol} {<218>}};
			#case {"Cyborg Guild"}		{#var {commcol} {<228>}};
			#case {"Cyborg Notify"}		{#var {commcol} {<268>}};
			#case {"Cyborg Syndicate"}	{#var {commcol} {<128>}};
			#case {"Eternal Main"}		{#var {commcol} {<168>}};
			#case {"Events"}		{#var {commcol} {<168>}};
			#case {"Explorer"}		{#var {commcol} {<178>}};
			#case {"Falcon"}		{#var {commcol} {<128>}};
			#case {"Gamers"}		{#var {commcol} {<268>}};
			#case {"Jedi"}			{#var {commcol} {<158>}};
			#case {"JEDI"}			{#var {commcol} {<128>}};
			#case {"JuggAnnounce"}		{#var {commcol} {<118>}};
			#case {"JuggMissiles"}		{#var {commcol} {<118>}};
			#case {"JuggNewbie"}		{#var {commcol} {<258>}};
			#case {"Lottery"}		{#var {commcol} {<178>}};
			#case {"Main"}			{#var {commcol} {<118>}};
			#case {"Newbie"}		{#var {commcol} {<138>}};
			#case {"Party"}			{#var {commcol} {<128>}};
			#case {"Poll"}			{#var {commcol} {<178>}};
			#case {"Professions"}		{#var {commcol} {<178>}};
			#case {"Psi Main"}		{#var {commcol} {<168>}};
			#case {"Shout"}			{#var {commcol} {<178>}};
			#case {"Whine"}			{#var {commcol} {<118>}};
			#case {"Wolf"}			{#var {commcol} {<228>}};
			#case {"Zilch_shout"}		{#var {commcol} {<168>}};
			#default			{#var {commcol} {<178>}}
		};
		

		#var {mip[comm][cdata]} {$mip[comm][data]};
		#replace {mip[comm][cdata]} {: } {: <099>};
		#var {mip[comm][cdata]} {$commcol$mip[comm][cdata]<099>};
		#if {$my[config][db][chat] == 1}{
			#var {dbmess}{$mip[comm][data]};
			db_submit_chat $dbmess;
		}{
			#line log {${logpath}/3s.chat} {$timestamp\};
			#line log {${logpath}/3s.chat} {$mip[comm][cdata]};
		};
		update_chat ${timestamp}$mip[comm][cdata];
		#if {$idle <= 900} {
			#NOP 8Inix;
			#if {"$8inix" == "on"} {
				#regex {$mip[comm][data]} {%i: 8inix} {
					do8inix
				}
			};

			#NOP IDefine;
			#if {"$idefine" == "on"} {
				#regex {$mip[comm][data]} {%i: idefine} {
					dodefine
				}
			};

			#NOP UDefine;
			#if {"$udefine" == "on"} {
				#regex {$mip[comm][data]} {%i: udefine} {
					doudefine
				}
			};

			#NOP ADDS;
			#if {"$adds" == "on"} {
				#regex {$mip[comm][data]} {%i: iwx} {
					doadds
				}
			};

			#NOP Stocks;
			#if {"$stocks" == "on"} {
				#regex {$mip[comm][data]} {%i: istocks} {
					dostocks
				} {
					#regex {$mip[comm][data]} {%i: istock} {
						dostock
					}
				}
			};

			#NOP Crypto;
			#if {"$crypto" == "on"} {
				#regex {$mip[comm][data]} {%i: icrypto} {
					docrypto
				}
			}
		}
	}
}

#NOP ***** Room Nouns Handling *****
#ALIAS {.mipProcessHAB} {
	#REGEX {%1} {{(.*)\~(.*)\~(.*)\~(.*)}} {
		#list {nouns} {fin} {&3} {noun_index};
		#if {$noun_index == 0} {
			#list {nouns} {add} {&3};
			#if {"$autosearch" == "on"} {
				exa &3;
				search &3
			}
		}
	}
}
#list {nouns} {create}

#NOP ***** Guild Stats Line Color Handling *****
#FUNCTION {fMipColorConv} {
	#VAR {result} {%1};
	#REPLACE {result} {>} {<099>};
	#REPLACE {result} {<b} {<848>};
	#REPLACE {result} {<c} {<868>};
	#REPLACE {result} {<g} {<828>};
	#REPLACE {result} {<r} {<818>};
	#REPLACE {result} {<s} {<278>};
	#REPLACE {result} {<v} {<858>};
	#REPLACE {result} {<w} {<178>};
	#REPLACE {result} {<y} {<838>}
}

#CLASS {mip} {close}
